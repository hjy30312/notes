### 1、谈下对五层网络协议体现结构的理解？

1.  **应用层**
    
    ​	应用层的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。对于不同的网络应用 需要不同的应用层协议。如域名系统DNS，支持万维网应用的HTTP协议，电子邮件的SMTP协议等。我们把应用层交互的数据单元称之为报文。
    
2.  **运输层**
    
     ​	运输层的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传输应用层报文。
    
     ​	由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用是指运输层把收到的信息分别交付上面应用层中相应进程。
    
3.  **网络层**
    
     ​	在计算机网络中进程通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交互结点，确保数据及时传送。 
    
4. **数据链路层**
   
       	数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。
   
5.  **物理层**
        在物理层上所传送的数据单位是比特。作用是实现相邻节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。




### 2、每一层对应的网络协议有哪些？

​	![](https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MztwWOtib1f2L7LqoiaOklu5b4ZkPbj0B04TPvzxxHImGYGOMnvMXfic5HKPdQGSCJsz92RE1IiaWiauYQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### 3、TCP和UDP的区别？

![](https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MztwWOtib1f2L7LqoiaOklu5bb6y2Sc0ZF88KzpG7ODYtQqGnI5HYUcqBhXaDicy55ic8pu9ymQzv3zEw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​		TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的运输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接节约系统资源），这难以避免增加了许多开销。

​	 	UDP在传送数据之前不需要先 建立连接，远地主机在收到UDP报文后，不需要给出任何确认。一般用于即时通信，比如：QQ语音、视频、直播等等。

### 4、详细说下TCP三次握手的过程？

​	![](https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MztwWOtib1f2L7LqoiaOklu5bicQP3xH7BM9KARUJYsYARKiaTQOou59SibR0LncP1fTn5sEOaOgDc8HWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​		最初客户端和服务端都处于CLOSED（关闭）状态。本例中A(Client)主动打开连接，B(Server)被动打开连接。

​		一开始，B的TCP服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于LISTEN（监听）状态，等待客户端的连接请求。如有，立刻作出响应。

​		第一次握手：A的TCP客户端进程也是首先创建传输控制块TCB。然后，再打算建立TCP连接时，向B发出连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能接待数据，但要消耗掉一个序号。这时，TCP客户进程进入SYN-SENT（同步已发送）状态。

​		第二次握手：B收到连接请求报文后，如果同意建立连接，则向A发送确认。 在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。 

​		第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y + 1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。 

	### 5、为什么两次握手不可以呢？

​		为了<font color="red">为了防止已经失效的连接请求报文段突然又传送到了B，因而产生错误。</font>例如：A发出的第一个连接请求报文段并没有丢失，而是在网络结点长时间滞留了，以致于延误到连接释放以后的某个时间段才到达B。本来这是一个早已失效的报文段。但是B收到此失效的连接请求报文段后，就误认为A又发出一次新的连接请求。B就向A发出确认报文段，建立连接。

​		B发出确认后建立连接，并一直等待A发来数据，实际上并没有。使用B的资源就这样浪费了。

### 6、TCP四次挥手

​		![](https://mmbiz.qpic.cn/mmbiz_png/I47RwB1Z6MztwWOtib1f2L7LqoiaOklu5bgRQODG29DS5WZLDgbarjuXS7R6xkxMvYHLbpNCrnThZoJgu1mfJ66A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

​		 第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。 

​		 第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。 

​		 第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。 