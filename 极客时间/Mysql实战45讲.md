### 01 | 基础架构：一条SQL查询语句是如何执行的？

![](https://github.com/hjy30312/picBed/blob/master/img/1.jpg?raw=true)

​																MySQL的逻辑架构图

大体来说，MySQL可以分为Server层和存储引擎层两部分。

Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM等多个存储引擎。

#### 连接器 

​	第一步，先连接到这个数据库上，这时候接待的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。`mysql - h$ip -P$port -u$user -p$password`

#### 查询缓存

​	第二步，查询缓存。MySQL拿到一个查询请求后，会先到查询缓存看看，之前是否执行过这条语句。之前执行过的语句及其结果可能会以key-value对的形式，被直接缓存在内存中。key是查询的语句，value是查询的结果。如果有缓存，则直接返回value，没有则执行完成后，执行结果存入查询缓存中。

##### 	但是大多数情况下不要使用查询缓存，往往弊大于利（8.0已删除查询缓存[官方说明]( https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/ ))

	1.  查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。
 	2.   对于面向用户的系统，降低性能的差异通常比提高峰值吞吐量更为重要。

#### 分析器

​	对SQL语句做解析。先会做“词法分析”，需要识别出里面的字符串分别是什么，代表什么。   其次“语法分析”，语法分析器会个根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。

#### 优化器

​	优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表有多表关联(join)的时候，决定各个表的连接顺序。

#### 执行器

	1. 先判断对表是否有查询权限。
 	2. 根据表的引擎定义，去使用这个引擎提供的接口

### 02 | 日志系统：一条SQL更新语句是如何执行的？

​	与SQL查询类似，分析器根据词法语法解析知道这是一条更新语句。优化器决定要使用ID这个索引。然后执行器负责具体执行，找到这一行，然后更新。

​	与查询流程不一样的是，更新流程还涉及到两个重要的日志模块，redo log（重做日志）和binlog（归档日志）。

#### 重要的日志模块：redo log

​	酒店掌柜有一个粉板，专门用来记录客人的赊账记录。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但是赊账的人多了，粉板总会有记不下的时候，这时候掌柜一定还有一个专门记录赊账的账本。

​	如果有人要还账或者赊账的话，掌柜一般有两种做法：

			1. 直接把账本翻出来，把这次赊的账加上去或者扣除掉；
   			2. 先在粉板上记下这次的帐，等打烊以后再把账本翻出来核算；

​	在MySQL里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程ID成本、查找成本都很高。为了解决这个问题，MySQL的设计者就用了类似酒店掌柜粉板的思路来更新效率。

​	具体来说，当有一条记录需要更新的时候，InnoDB引擎就会先把记录写到redo log（粉板）里面，并更新内存，这个时候更新就算完成了。InnoDB引擎会在适当的时候，将这个操作更新到磁盘里面，而这个更新往往是系统比较空闲的时候做，这就像打烊以后掌柜做的事。

​	当粉板写满后，掌柜放下手中的活儿，把粉板一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。与此类似，InnoDB的redo log是固定大小的，可以配置一组4个文件，每个文件
的大小是 1GB，总共就4G。

​	有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为`crash-safe`。

#### 重要的日志模块：bin log

​	粉板redo log是InnoDB引擎特有的日志，而Server层也有自己的日志，称为binlog（归档日志）。

​	这两种日志有以下三点不同。

	1.  redo log是InnoDB引擎特有的；binlog 是MySQL的Server层实现的，所有引擎都可以使用。
 	2.  redo log是物理日志，记录的是"在某个数据页上做了什么修改"；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如”给ID=2这一行的c字段加1“。
 	3.  redo log循环写的，空间固定会用完；binlog是可以追加写入的。追加写是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。



​	update语句的执行流程图，图中浅色框表示是在InnoDB内部执行的，深色框表示是在执行器中执行的。

​		 ![](https://github.com/hjy30312/picBed/blob/master/img/update%E6%B5%81%E7%A8%8B.png?raw=true)

​										update 语句执行流程

##### 两阶段提交

​	为什么必须“两阶段提交“呢？ 这是为了让两份日志之间的逻辑一致。先写redo log后写binlog与先写binlog后写rdo log都有可能和用它的日志恢复出来的库的状态不一致。

 















