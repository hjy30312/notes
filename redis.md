## redis

### 为什么快

1. 基于内存
2. 多路复用io阻塞机制（epoll）
3. 数据结构简单
4. 单线程，避免了不必要的上下文切换和竞争条件，无需考虑锁。容易实现，而且CPU不会成为瓶颈

### 常见数据结构以及使用常见

#### String

> 常用命令：set,get,decr,incr,mget等。

String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-
value缓存应⽤； 常规计数：微博数，粉丝数等。

#### Hash

> 常用命令：hget,hset,hgetall等

hash特别适合于存储对象，比如我们可以hash数据结构来存储用户信息，商品信息等等。比如下面我就用hash类型存放了我本人的一些信息：

```json
key=JavaUser293847
value={
    “id”: 1,
    “name”: “SnailClimb”,
    “age”: 22,
    “location”: “Wuhan, Hubei”
}
```

#### List

> 常用命令：lpush,rpush,lpop,rpop,lrange等

链表，微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的list结构来实现。

实现为⼀个双向链表，即可以⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外
的内存开销。

另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分⻚查询，这
个很棒的⼀个功能，基于 redis 实现简单的⾼性能分⻚，可以做类似微博那种下拉不断分⻚的东⻄
（⼀⻚⼀⻚的往下⾛），性能⾼。

#### Set

> 常⽤命令： sadd,spop,smembers,sunion 等

set与list的区别在于set是可以自动排重的。可以基于set实现交集、并集、差集的操作。

比如：微博应用中的共同关注，共同粉丝，共同喜好等功能。

#### Sorted Set

> 常用命令： zadd，zrange，zrem,zcard等

具体实现原理为：跳表（二分思想），即多层链表，插入元素时自底向上，上层是否插入的思路是抛硬币，随机的。

和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。

比如：排行榜

### 持久化

#### RDB

#### AOF

#### 混合持久化

### 过期策略

过期建是保存在哈希表中的。那些过期键到了过期的时间就会立马被删除掉吗？过期策略主要分为三种：

- 定时删除（对内存友好，对CPU不友好）
  - 到时间点把所有过期的建删除了
- 惰性产生（对CPU极度友好，对内存极度不友好）
  - 每次从键空间取键的时候，判断该键是否过期了，如果过期了就删除。
- 定期删除（折中）
  - 每隔一段时间就去删除过期键，限制删除的执行时长和频率。

Redis采用的是**惰性删除+定期删除**两种策略，所以说，在Redis里边如果过期键到了过期的时间了，未必被立马删除的！

----



## 集群

### 主从

当主节点（Master）挂掉的时候，运维让从节点（Slave）过来接管，服务就可以继续，否则主节点需要经过数据恢复和重启的过程，就会拖延很长时间。

- 主服务器负责接收写请求
- 从服务器负责接收读请求
- 从服务器的数据由主服务器复制过去。主从服务器的数据是一致的。

#### CAP原理

CAP原理是分布式存储的理论基石。

- C：Consisten,一致性
- A：Availability,可用性
- P：Partition tolerance，分区容忍性

分布式系统的节点通常都是分布在不同的机器上，意味着必然会有网络断开的风险，网络断开的场景专业词汇叫做**网络分区**。

用一句话概括CAP原理就是：**当网络分区发生时，一致性和可用性两难全**。

#### 最终一致

Redis的主从数据是异步同步的，所以分布式Redis不满足**一致性**。当发生网络分区时，节点依旧正常对外提供服务，满足**可用性**。

Redis保证**最终一致性**，网络恢复后，redis会尽力保持一致。

### 哨兵-Sentinel

当主服务器挂掉后，需要手工进行主从切换，我们需要有一个高可用方案来抵抗节点故障，当故障产生时可以自动进行主从切换。Redis官方提供了一种方案--- Redis Sentinel

Sentinel负责持续监控主从节点健康，当主节点挂掉时，自动选择一个最优的从节点切换成主节点，其他节点开始与新的节点建立复制关系。当原先挂掉的主节点恢复后，变成从节点。

#### 消息丢失

Sentinel无法保证消息完全不丢失，但是也尽量保证消息少丢失。有两个选项可以限制主从延迟过大。

```
min-slaves-to-write 1
min-slaves-max-lag 10
```

第一个参数表示至少有一个从节点在进行正常复制，否则就停止对外写服务，丧失可用性。

第二个参数，如果10s内没有收到从节点的反馈，就意味着同步不正常。

### 分而治之-Codis

Codis算是客户端与redis之间的代理中间件。当客户端向Codis发送指令时，Codis负责将指令转发到后面的Redis执行，并将返回结果再转回给客户端。

Codis上挂接的所有Redis实例构成一个Redis集群，当集群空间不足时，可以通过动态增加Redis实例来实现扩容需求。

Codis是无状态的，只是一个转发代理中间件。所以我们可以启动多个Codis代理增加整体的QPS，还能起到容灾的功能。

##### 优点

方案简单，将分布式的问题交给了第三方（zookeeper或etcd）去负责，内部实现相对Redis Cluster的简单。

#### 





