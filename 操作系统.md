## 进程间的通信

每个进程的用户地址空间都是独立的，一般而言是不能相互访问的，但内核空间是每个进程都共享的，索引进程之间要通信必须通过内核。

![](https://github.com/hjy30312/picBed/blob/master/img/微信图片_20200827223444.jpg?raw=1)



### 管道

`ps auxf | grep mysql`命令行的|就是一个管道， 它的功能是将前一个命令（`ps auxf`）的输出，作为后一个命令（`grep mysql`）的输入，从这功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行。 



同时，上面这种没有名字的管道称为**匿名管道**，还有另外一个类型是**命名管道**。数据是先进先出的传输方式。

当数据写进管道后，管道后的数据必须被读取才可以正常退出。可以看出：**管道这种通信方式效率低，不适合进程间频繁地交换数据。**



>背后原理是什么呢？

**所谓的管道，就是内核里面的一串缓存**。一端缓存在内核中，另一端从内核中读取。 



**对于匿名管道，它的通信范围是存在父子关系的进程**。因为管道没有实体，也就是没有管道文件，只能通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。

另外，**对于命名管道，它可以在不相关的进程间也能相互通信**。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。

### 消息队列

管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。

消息队列的通信模式就可以解决。A进程要给B进程发送消息，A进程只需要把数据放在对应的消息队列后就可以正常返回了。

**消息队列是保存在内核中的消息链表，**在发送数据时，会分成一个一个独立的数据块。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

<font color="blue">消息队列不适合比较大数据的传输</font>，因为在内核中每个消息体都有一个最大长度的限制。<font color="blue">消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销。</font>



### 共享内存

<font color="blue">共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。</font>

![https://github.com/hjy30312/picBed/blob/master/img/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg](https://github.com/hjy30312/picBed/blob/master/img/共享内存.jpg?raw=1)

 



### 信号量

用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。<font color="blue">信号量</font>就实现了这一个保护机制。



<font color="blue>"信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</font>。

信号量表示资源的数量，控制信号量的方式有两种原子操作：

- 一个是 **P 操作**，这个操作会把信号量减去 -1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- 另一个是 **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

 

信号初始化为 `1`，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。 

 可以发现，信号初始化为 `0`，就代表着是**同步信号量**，它可以保证进程 A 应在进程 B 之前执行。



### 信号

 上面说的进程间通信，都是常规状态下的工作模式。**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程。** 



运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束；



 信号是进程间通信机制中**唯一的异步通信机制** 



### Socket

