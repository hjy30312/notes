### 3、守护线程是什么？

​	守护线程（Daemon thread），是个服务线程，准确地来说就是服务其他的线程。

### 4、创建线程的几种方式？

	1.  继承Thread类创建线程；
 	2.  实现Runnable接口创建线程；
 	3.  通过Callable和Future创建线程；
 	4.  通过线程池创建线程。

### 5、sleep()和wait()的区别？

	1.  sleep() 方法正在执行的线程主动让出cpu（cpu去执行其他任务），在sleep指定时间后cpu再回到该线程继续往下执行（并不会释放同步资源锁）；而wait() 方法则是指当前线程让自己暂时退让出同步资源锁，以便其他正在等待该资源的线程得到该资源进而运行，只有调用了notify()方法，之前调用的wait()的线程才会解除wait状态，可以去参与竞争同步资源锁，进而得到执行。
 	2.  sleep() 方法可以在任何地方使用，而wait()方法则只能在同步方法或同步块中使用。

### 6、说一说对于synchronized关键字的了解？

​	synchronized关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

​	在Java早期版本中，synchronized属于重量级锁，效率低下，Java的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，耗时。 现在的 synchronized 锁效率也优化得很不错了。JDK6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。 



### 

### 7、讲一下synchronized关键字的底层原理？//todo

### 8、 说说JDK1.6之后的synchronized关键字底层做了哪些优化，可以详细介绍一下这些优化吗？//todo



### 9、谈一下volatile关键字的理解？

​	volatile关键字是用来保证有序性和可见性的。这跟Java内存模型有关。我们所写的代码，不一定是按照我们自己书写的顺序来执行的，编译器会做重排序，CPU也会做重排序的，这样做事为了减少流水线阻塞，提高CPU的执行效率。实现：通过插入内存屏障来保证的。

​	被volatile修饰的共享变量，就有了以下两点特性：

1. 保证了不同线程对该变量操作的内存可见性；
2. 禁止执行重排序。

### 10、悲观锁和乐观锁

- 悲观锁

  总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。

- 乐观锁

  总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。





