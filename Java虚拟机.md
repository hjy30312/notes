### 1、谈谈对运行时数据区的理解？

 - 程序计数器

   ​	Program Counter Register : 是一块比较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。

   ​	字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。程序的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

   ​	由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器都只会执行一条线程中的命令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储，我们称这块内存区域为“线程私有”的内存。

- Java虚拟机栈

  ​	Java Virtual Machine Stack：描述的是Java方法执行内存模型：每个方法在执行的同事都会创建一个帧栈（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。它的线程也是私有的，生命周期与线程相同。

  ​	Java虚拟机栈有两种异常状况：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常； 如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

- 本地方法栈

  ​	Native Method Stock: 与虚拟机栈作用相似，本地方法栈为虚拟机使用到的Native方法服务。

- Java堆

  ​	Java Heap: 是被所有线程所共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是：存放对象实例，几乎所有的对象实例都在这里分配内存。

  ​	Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC”堆（Garbage Collected Heap）。从内存回收的角度看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代。

  ​	Java虚拟机规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的既可。在实现时，可以是固定大小的，也可以是可扩展的。如果在队中没有完成实例分配。并且堆也无法扩展时，将会抛出OutOfMemoryError。

- 方法区

  ​	Method Area: 与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

  ​	运行时常量池（Runtime Constant Pool）: 是方法区的一比分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一些信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。

### 2、 堆和栈的区别是什么？

​		堆和栈是完全不同的两块内存区域，一个是线程独享的，一个是线程共享的。二者之间最大的区别就是存储的内容不同：堆中主要存放对象实例。栈中主要存放各种基本数据类型、对象的引用。

​		从作用来说，栈是运行时的单位，而堆是存储的单位。栈解决程序的运行问题，即程序如何执行，或者如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。

### 3、堆中存什么？ 栈中存什么？

​		堆中存的是对象。栈中存的是基本数据类型和堆中对象的引用。一个对象的大小是不可估计的，或者说是可以动态变化的，但是在栈中，一个对象只对应了一个4btye的引用（堆栈分离的好处）。

### 4、判断垃圾可以回收的方法有哪些？

  - 引用计数法

      - 基本思想

        ​	引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其他变量被赋值为这个对象的引用时，计数+1（a = b，b计数加一），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

    - 优缺点

      ​	优点：引用计数收集器可以很快的执行，交织在程序运行中。

      ​	缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。他们的引用计数永远不可能是0。

- 可达性分析算法

  ​	可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，将会被判定为可回收的对象。

  ![](C:\Users\何大洋\Desktop\微信图片_20191103220652.jpg)

### 5、被标记为垃圾的对象一定会被回收吗？

​	即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段。<font color="red">要真正宣告一个对象死亡，至少要经历两次标记过程。</font>

​	第一次标记：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；

​	第二次标记：第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。在finalize()方法中没有重新与引用链建立关联关系的，将被进行第二次标记。第二次标记成功的对象将真的会被回收，如果对象在finalize()方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。

### 6、谈谈对内存泄漏的理解？

 - 内存泄漏的基本概念

   ​	在Java中，内存泄漏就是存在一些不会再被使用缺没有被回收的对象，这些对象有下面两个特点：

    1. 这些对象是可达的，即在有向图中，存在通过可以与其相连；

    2. 这些对象时无用的，即程序以后不会再使用这些对象。

       如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而他却占用内存。



























